# 1、阅读 Pseudocode Standard。（答案可以打印）
## 1）用伪代码描述将十进制转换成16进制的方法
```
READ 十进制数x；
IF 十进制数x==0 THEN
    PRINT 0
ELSE
    INIT SIGN == 0
    INIT y == 0 
    INIT b   
    SET    result[]
    WHILE x != 0
        IF X<0 THEN
            COMPUTE X = -X
            COMPUTE SIGN = SIGN + 1
        END IF    
        COMPUTE b AS X % 16
        IF b>0 and b<10 THEN
            result[y]=b
        ELSE
            CASE b OF
                10  :   result[y]=A
                11  :   result[y]=B
                12  :   result[y]=C
                13  :   result[y]=D
                14  :   result[y]=E
                15  :   result[y]=F
            END CASE
        END IF
        COMPUTE X = X/16
    END WHILE
    IF SIGN == 1 THEN
        PRINT '-'
    END IF    
    WHILE y>=0
        PRINT result[y]
        COMPUTE y = y-1 
    END WHILE
END IF    
```



2）C语言实现（先用注释写好算法，然后翻译）
```
#include<stdio.h>
int main(){
	int x;
	int sign=0;
	int y=0;
	int count=0;
	char result[100]={'0'};
	scanf("%d",&x);
	if(x==0){
		printf("0");
	}
	else{
		if(x<0){
			x=0-x;
			++sign;
		}
		while(x>0){
			y=x%16;
			if(y>=0&&y<10){
				result[count]='0'+y;				
			}
			else{
				result[count]='A'+y-10;
			}
			x=x/16;
			++count;
		}
		if(sign==1){
			putchar('-');
		}
		while(count>=0){
			printf("%c",result[count-1]);
			--count;
		}
	}
		
}
```
## 3）使用 -1, 0, 1, 15, 26，3265 最为输入测试你的程序

-1, 0, 1, F, 1A, CC1

# 2、名词解释与对比
## 1）Top-down design
Top-down and bottom-up are both strategies of information processing and knowledge ordering, used in a variety of fields including software, humanistic and scientific theories (see systemics), and management and organization.

自上而下和自下而上都是信息处理和知识排序的策略，用于各种领域，包括软件，人文和科学理论（参见系统学），以及管理和组织。

## 2） Work breakdown structure (WBS)
A work-breakdown structure (WBS) in project management and systems engineering, is a deliverable-oriented breakdown of a project into smaller components. 

在专案管理和系统工程中，工作分解结构〈或称为承包商工作分解结构，是将一个工作计划细分为较小的部分来分工完成。



## 3）简述管理学 WBS 与 信息学Top-down设计 的异同
同：两者都是将一个工作计划（任务）或是一个系统拆分开来进行操作

异：WBS是将任务拆分成同级的更小的部分来分工，虽然有执行顺序上的差异，但每一份工作完成时都不依赖他人的工作过程，只需要结果（如产品）。每部分是独立的。

TOP-down 设计更像是一种思维方式。它将一个复杂行为从结果不断倒推，来推算子系统的行为，每一层的行为之间是逻辑关联的，很多个子系统的行为共同导致了母系统的判断。直到推演到最单一的动作行为。

# 3、仔细观察您洗衣机的运作过程，运用Top-down设计方法和Pseudocode 描述洗衣机控制程序。假设洗衣机可执行的基本操作如下water_in_switch(open_close) // open 打开上水开关，close关闭water_out_switch(open_close) // open 打开排水开关，close关闭get_water_volume() //返回洗衣机内部水的高度motor_run(direction) // 电机转动。left左转，right右转，stop停time_counter() // 返回当前时间计数，以秒为单位halt(returncode) //停机，success 成功 failure 失败

## 1）请使用伪代码分解“正常洗衣”程序的大步骤。包括注水、浸泡等
```
READ 洗衣模式 ， 洗衣时间 ， 水量
注水
浸泡
甩动
脱水
二次注水
甩动
脱水
甩干
```

## 2）进一步用基本操作、控制语句（IF、FOR、WHILE等）、变量与表达式，写出每个步骤的伪代码
```
READ 洗衣模式 ，浸泡时间 ，甩动时间， 设定水量


water_in_switch(open)
REPEAT
    get_water_volume(水量)
UNTIL 水量>=设定水量
water_in_switch(close)


REPEAT
    time_counter(时间)
UNTIL 时间>=浸泡时间


REPEAT
    motor_run(left)
    motor_run(right)
    time_counter(时间)
UNTIL 时间>=甩动时间
moter_run(stop)


water_out_switch(open)
REPEAT
    get_water_volume(水量)
UNTIL 水量=0;
waher_out_switch(close)


water_in_switch(open)
REPEAT
    get_water_volume(水量)
UNTIL 水量>=设定水量
water_in_switch(close)


REPEAT
    motor_run(left)
    motor_run(right)
    time_counter(时间)
UNTIL 时间>=甩动时间
moter_run(stop)


water_out_switch(open)
REPEAT
    get_water_volume(水量)
UNTIL 水量=0;
waher_out_switch(close)

REPEAT
    motor_run(left)
    motor_run(right)
    time_counter(时间)
UNTIL 时间>=甩动时间
moter_run(stop)

halt
```


## 3）根据你的实践，请分析“正常洗衣”与“快速洗衣”在用户目标和程序上的异同。你认为是否存在改进（创新）空间，简单说明你的改进意见？

这两者的用户目标同在都希望清洗衣物。异在于“正常洗衣”的用户更追求衣物清洗的干净程度，而“快速洗衣”的用户更追求速度，追求更快拿到衣服。

程序上同在都要注水，加入洗衣液，甩动，脱水，甩干。异在于“正常洗衣”多了浸泡的步骤并且甩动时间更短，脱水注水（换水）的次数更少。

我认为在快速洗衣时甩动频率可以更高，幅度更大，减少每次注水的量。或者对于洗衣店可以开发快速洗衣专用机，除去一些不需要的部件，只用于快速洗衣的客户，节约成本。


## 4）通过步骤3），提取一些共性功能模块（函数），简化“正常洗衣”程序，使程序变得更利于人类理解和修改维护。例如：wait(time) //等待指定的时间；注水(volume,timeout) //在指定时间内完成注水，否则停机；排水(timeout)。 等子程序
```
wait(time){
    REPEAT
    time_counter(时间)
UNTIL 时间>=time
}


注水(volume,timeout){
    water_in_switch(open)
    REPEAT
        time_counter(时间)
        IF 时间>=timeout
            halt
        END IF    
        get_water_volume(水量)
    UNTIL 水量>=volume
    water_in_switch(close)
}

排水（timeout）{
    water_out_switch(open)
    REPEAT
        time_counter(时间)
        IF 时间>=timeout
            halt
        END IF    
        get_water_volume(水量)
    UNTIL 水量=0
    water_out_switch(close)
}

甩动（甩动时间）{
    REPEAT
    motor_run(left)
    motor_run(right)
    time_counter(时间)
UNTIL 时间>=甩动时间
moter_run(stop)
}


